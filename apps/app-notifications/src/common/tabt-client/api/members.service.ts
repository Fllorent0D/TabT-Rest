/**
 * TabT Rest
 * This api is a bridge to the TabT SOAP API. It contacts TabT and cache results in order to reduce latency for some requests. More documentation will come.<br>       The data present in the api such as player names, club names, tournaments or match results are not managed by us. This information is made freely available by the Aile Francophone de Tennis de Table and the Vlaamse Tafeltennisliga. We therefore cannot be held responsible for the publication of this information. If changes need to be made, you should contact the responsible entity.     If you build an application on top of the BePing\'s api, be sure to do at least one of the following things:         <ul><li>If possible, set a X-Application-For header string. Include the name of your application, and a way to contact you in case something would go wrong.<br>       An example user agent string format is, which could result in the following string: beping/2.0.0 (floca.be; florent@floca.be). The use of a header like this isnâ€™t obligated or enforced, but allows for better communication.</li></ul>
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: f.cardoen@me.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { AxiosResponse } from 'axios';
import { Observable, of, switchMap } from 'rxjs';
import { MemberEntry } from '../model/memberEntry';
import { WeeklyNumericRanking } from '../model/weeklyNumericRanking';
import { WeeklyNumericRankingV2 } from '../model/weeklyNumericRankingV2';
import { WeeklyNumericRankingV3 } from '../model/weeklyNumericRankingV3';
import { Configuration } from '../configuration';

@Injectable()
export class MembersService {
  protected basePath = 'http://localhost:3004';
  public defaultHeaders: Record<string, string> = {};
  public configuration = new Configuration();

  constructor(
    protected httpClient: HttpService,
    @Optional() configuration: Configuration,
  ) {
    this.configuration = configuration || this.configuration;
    this.basePath = configuration?.basePath || this.basePath;
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data';
    return consumes.includes(form);
  }

  /**
   *
   *
   * @param club
   * @param playerCategory
   * @param uniqueIndex
   * @param nameSearch
   * @param extendedInformation
   * @param rankingPointsInformation
   * @param withResults
   * @param withOpponentRankingEvaluation
   * @param xTabtAccount Account to do a request
   * @param xTabtPassword Password of the account
   * @param xTabtOnBehalfOf On Behalf of
   * @param xTabtDatabase Database to query
   * @param xTabtSeason Season name to query
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findAllMembers(
    club?: string,
    playerCategory?: 1 | 2 | 3 | 4 | 5 | 37 | 38 | 41,
    uniqueIndex?: number,
    nameSearch?: string,
    extendedInformation?: boolean,
    rankingPointsInformation?: boolean,
    withResults?: boolean,
    withOpponentRankingEvaluation?: boolean,
    xTabtAccount?: string,
    xTabtPassword?: string,
    xTabtOnBehalfOf?: string,
    xTabtDatabase?: 'aftt' | 'vttl',
    xTabtSeason?: string,
  ): Observable<AxiosResponse<Array<MemberEntry>>>;
  public findAllMembers(
    club?: string,
    playerCategory?: 1 | 2 | 3 | 4 | 5 | 37 | 38 | 41,
    uniqueIndex?: number,
    nameSearch?: string,
    extendedInformation?: boolean,
    rankingPointsInformation?: boolean,
    withResults?: boolean,
    withOpponentRankingEvaluation?: boolean,
    xTabtAccount?: string,
    xTabtPassword?: string,
    xTabtOnBehalfOf?: string,
    xTabtDatabase?: 'aftt' | 'vttl',
    xTabtSeason?: string,
  ): Observable<any> {
    const queryParameters = new URLSearchParams();
    if (club !== undefined && club !== null) {
      queryParameters.append('club', <any>club);
    }
    if (playerCategory !== undefined && playerCategory !== null) {
      queryParameters.append('playerCategory', <any>playerCategory);
    }
    if (uniqueIndex !== undefined && uniqueIndex !== null) {
      queryParameters.append('uniqueIndex', <any>uniqueIndex);
    }
    if (nameSearch !== undefined && nameSearch !== null) {
      queryParameters.append('nameSearch', <any>nameSearch);
    }
    if (extendedInformation !== undefined && extendedInformation !== null) {
      queryParameters.append('extendedInformation', <any>extendedInformation);
    }
    if (
      rankingPointsInformation !== undefined &&
      rankingPointsInformation !== null
    ) {
      queryParameters.append(
        'rankingPointsInformation',
        <any>rankingPointsInformation,
      );
    }
    if (withResults !== undefined && withResults !== null) {
      queryParameters.append('withResults', <any>withResults);
    }
    if (
      withOpponentRankingEvaluation !== undefined &&
      withOpponentRankingEvaluation !== null
    ) {
      queryParameters.append(
        'withOpponentRankingEvaluation',
        <any>withOpponentRankingEvaluation,
      );
    }

    const headers = { ...this.defaultHeaders };
    if (xTabtAccount !== undefined && xTabtAccount !== null) {
      headers['X-Tabt-Account'] = String(xTabtAccount);
    }
    if (xTabtPassword !== undefined && xTabtPassword !== null) {
      headers['X-Tabt-Password'] = String(xTabtPassword);
    }
    if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
      headers['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
    }
    if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
      headers['X-Tabt-Database'] = String(xTabtDatabase);
    }
    if (xTabtSeason !== undefined && xTabtSeason !== null) {
      headers['X-Tabt-Season'] = String(xTabtSeason);
    }

    const accessTokenObservable: Observable<any> = of(null);

    // to determine the Accept header
    const httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers['Accept'] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers['Authorization'] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<Array<MemberEntry>>(
          `${this.basePath}/v1/members`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
          },
        );
      }),
    );
  }
  /**
   *
   *
   * @param query
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findAllMembersLookup(
    query: string,
  ): Observable<AxiosResponse<Array<MemberEntry>>>;
  public findAllMembersLookup(query: string): Observable<any> {
    if (query === null || query === undefined) {
      throw new Error(
        'Required parameter query was null or undefined when calling findAllMembersLookup.',
      );
    }

    const queryParameters = new URLSearchParams();
    if (query !== undefined && query !== null) {
      queryParameters.append('query', <any>query);
    }

    const headers = { ...this.defaultHeaders };

    const accessTokenObservable: Observable<any> = of(null);

    // to determine the Accept header
    const httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers['Accept'] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers['Authorization'] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<Array<MemberEntry>>(
          `${this.basePath}/v1/members/lookup`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
          },
        );
      }),
    );
  }
  /**
   *
   *
   * @param uniqueIndex
   * @param club
   * @param playerCategory
   * @param nameSearch
   * @param extendedInformation
   * @param rankingPointsInformation
   * @param withResults
   * @param withOpponentRankingEvaluation
   * @param xTabtAccount Account to do a request
   * @param xTabtPassword Password of the account
   * @param xTabtOnBehalfOf On Behalf of
   * @param xTabtDatabase Database to query
   * @param xTabtSeason Season name to query
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findMemberById(
    uniqueIndex: number,
    club?: string,
    playerCategory?: 1 | 2 | 3 | 4 | 5 | 37 | 38 | 41,
    nameSearch?: string,
    extendedInformation?: boolean,
    rankingPointsInformation?: boolean,
    withResults?: boolean,
    withOpponentRankingEvaluation?: boolean,
    xTabtAccount?: string,
    xTabtPassword?: string,
    xTabtOnBehalfOf?: string,
    xTabtDatabase?: 'aftt' | 'vttl',
    xTabtSeason?: string,
  ): Observable<AxiosResponse<MemberEntry>>;
  public findMemberById(
    uniqueIndex: number,
    club?: string,
    playerCategory?: 1 | 2 | 3 | 4 | 5 | 37 | 38 | 41,
    nameSearch?: string,
    extendedInformation?: boolean,
    rankingPointsInformation?: boolean,
    withResults?: boolean,
    withOpponentRankingEvaluation?: boolean,
    xTabtAccount?: string,
    xTabtPassword?: string,
    xTabtOnBehalfOf?: string,
    xTabtDatabase?: 'aftt' | 'vttl',
    xTabtSeason?: string,
  ): Observable<any> {
    if (uniqueIndex === null || uniqueIndex === undefined) {
      throw new Error(
        'Required parameter uniqueIndex was null or undefined when calling findMemberById.',
      );
    }

    const queryParameters = new URLSearchParams();
    if (club !== undefined && club !== null) {
      queryParameters.append('club', <any>club);
    }
    if (playerCategory !== undefined && playerCategory !== null) {
      queryParameters.append('playerCategory', <any>playerCategory);
    }
    if (nameSearch !== undefined && nameSearch !== null) {
      queryParameters.append('nameSearch', <any>nameSearch);
    }
    if (extendedInformation !== undefined && extendedInformation !== null) {
      queryParameters.append('extendedInformation', <any>extendedInformation);
    }
    if (
      rankingPointsInformation !== undefined &&
      rankingPointsInformation !== null
    ) {
      queryParameters.append(
        'rankingPointsInformation',
        <any>rankingPointsInformation,
      );
    }
    if (withResults !== undefined && withResults !== null) {
      queryParameters.append('withResults', <any>withResults);
    }
    if (
      withOpponentRankingEvaluation !== undefined &&
      withOpponentRankingEvaluation !== null
    ) {
      queryParameters.append(
        'withOpponentRankingEvaluation',
        <any>withOpponentRankingEvaluation,
      );
    }

    const headers = { ...this.defaultHeaders };
    if (xTabtAccount !== undefined && xTabtAccount !== null) {
      headers['X-Tabt-Account'] = String(xTabtAccount);
    }
    if (xTabtPassword !== undefined && xTabtPassword !== null) {
      headers['X-Tabt-Password'] = String(xTabtPassword);
    }
    if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
      headers['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
    }
    if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
      headers['X-Tabt-Database'] = String(xTabtDatabase);
    }
    if (xTabtSeason !== undefined && xTabtSeason !== null) {
      headers['X-Tabt-Season'] = String(xTabtSeason);
    }

    const accessTokenObservable: Observable<any> = of(null);

    // to determine the Accept header
    const httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers['Accept'] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers['Authorization'] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MemberEntry>(
          `${this.basePath}/v1/members/${encodeURIComponent(String(uniqueIndex))}`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
          },
        );
      }),
    );
  }
  /**
   *
   *
   * @param uniqueIndex
   * @param nameSearch
   * @param shortNameSearch
   * @param rankingCategory
   * @param xTabtAccount Account to do a request
   * @param xTabtPassword Password of the account
   * @param xTabtOnBehalfOf On Behalf of
   * @param xTabtDatabase Database to query
   * @param xTabtSeason Season name to query
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findMemberCategories(
    uniqueIndex?: number,
    nameSearch?: string,
    shortNameSearch?: string,
    rankingCategory?: string,
    xTabtAccount?: string,
    xTabtPassword?: string,
    xTabtOnBehalfOf?: string,
    xTabtDatabase?: 'aftt' | 'vttl',
    xTabtSeason?: string,
  ): Observable<AxiosResponse<MemberEntry>>;
  public findMemberCategories(
    uniqueIndex?: number,
    nameSearch?: string,
    shortNameSearch?: string,
    rankingCategory?: string,
    xTabtAccount?: string,
    xTabtPassword?: string,
    xTabtOnBehalfOf?: string,
    xTabtDatabase?: 'aftt' | 'vttl',
    xTabtSeason?: string,
  ): Observable<any> {
    const queryParameters = new URLSearchParams();
    if (uniqueIndex !== undefined && uniqueIndex !== null) {
      queryParameters.append('uniqueIndex', <any>uniqueIndex);
    }
    if (nameSearch !== undefined && nameSearch !== null) {
      queryParameters.append('nameSearch', <any>nameSearch);
    }
    if (shortNameSearch !== undefined && shortNameSearch !== null) {
      queryParameters.append('shortNameSearch', <any>shortNameSearch);
    }
    if (rankingCategory !== undefined && rankingCategory !== null) {
      queryParameters.append('rankingCategory', <any>rankingCategory);
    }

    const headers = { ...this.defaultHeaders };
    if (xTabtAccount !== undefined && xTabtAccount !== null) {
      headers['X-Tabt-Account'] = String(xTabtAccount);
    }
    if (xTabtPassword !== undefined && xTabtPassword !== null) {
      headers['X-Tabt-Password'] = String(xTabtPassword);
    }
    if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
      headers['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
    }
    if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
      headers['X-Tabt-Database'] = String(xTabtDatabase);
    }
    if (xTabtSeason !== undefined && xTabtSeason !== null) {
      headers['X-Tabt-Season'] = String(xTabtSeason);
    }

    const accessTokenObservable: Observable<any> = of(null);

    // to determine the Accept header
    const httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers['Accept'] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers['Authorization'] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MemberEntry>(
          `${this.basePath}/v1/members/categories`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
          },
        );
      }),
    );
  }
  /**
   *
   *
   * @param uniqueIndex
   * @param season
   * @param category
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findMemberNumericRankingsHistory(
    uniqueIndex: number,
    season?: number,
    category?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH',
  ): Observable<AxiosResponse<Array<WeeklyNumericRanking>>>;
  public findMemberNumericRankingsHistory(
    uniqueIndex: number,
    season?: number,
    category?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH',
  ): Observable<any> {
    if (uniqueIndex === null || uniqueIndex === undefined) {
      throw new Error(
        'Required parameter uniqueIndex was null or undefined when calling findMemberNumericRankingsHistory.',
      );
    }

    const queryParameters = new URLSearchParams();
    if (season !== undefined && season !== null) {
      queryParameters.append('season', <any>season);
    }
    if (category !== undefined && category !== null) {
      queryParameters.append('category', <any>category);
    }

    const headers = { ...this.defaultHeaders };

    const accessTokenObservable: Observable<any> = of(null);

    // to determine the Accept header
    const httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers['Accept'] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers['Authorization'] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<Array<WeeklyNumericRanking>>(
          `${this.basePath}/v1/members/${encodeURIComponent(String(uniqueIndex))}/numeric-rankings`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
          },
        );
      }),
    );
  }
  /**
   *
   *
   * @param uniqueIndex
   * @param category
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findMemberNumericRankingsHistoryV2(
    uniqueIndex: number,
    category?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH',
  ): Observable<AxiosResponse<Array<WeeklyNumericRankingV2>>>;
  public findMemberNumericRankingsHistoryV2(
    uniqueIndex: number,
    category?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH',
  ): Observable<any> {
    if (uniqueIndex === null || uniqueIndex === undefined) {
      throw new Error(
        'Required parameter uniqueIndex was null or undefined when calling findMemberNumericRankingsHistoryV2.',
      );
    }

    const queryParameters = new URLSearchParams();
    if (category !== undefined && category !== null) {
      queryParameters.append('category', <any>category);
    }

    const headers = { ...this.defaultHeaders };

    const accessTokenObservable: Observable<any> = of(null);

    // to determine the Accept header
    const httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers['Accept'] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers['Authorization'] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<Array<WeeklyNumericRankingV2>>(
          `${this.basePath}/v2/members/${encodeURIComponent(String(uniqueIndex))}/numeric-rankings`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
          },
        );
      }),
    );
  }
  /**
   *
   *
   * @param uniqueIndex
   * @param category
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findMemberNumericRankingsHistoryV3(
    uniqueIndex: number,
    category?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH',
  ): Observable<AxiosResponse<WeeklyNumericRankingV3>>;
  public findMemberNumericRankingsHistoryV3(
    uniqueIndex: number,
    category?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH',
  ): Observable<any> {
    if (uniqueIndex === null || uniqueIndex === undefined) {
      throw new Error(
        'Required parameter uniqueIndex was null or undefined when calling findMemberNumericRankingsHistoryV3.',
      );
    }

    const queryParameters = new URLSearchParams();
    if (category !== undefined && category !== null) {
      queryParameters.append('category', <any>category);
    }

    const headers = { ...this.defaultHeaders };

    const accessTokenObservable: Observable<any> = of(null);

    // to determine the Accept header
    const httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers['Accept'] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers['Authorization'] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<WeeklyNumericRankingV3>(
          `${this.basePath}/v3/members/${encodeURIComponent(String(uniqueIndex))}/numeric-rankings`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
          },
        );
      }),
    );
  }
  /**
   *
   *
   * @param uniqueIndex
   * @param category
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findMemberNumericRankingsHistoryV4(
    uniqueIndex: number,
    category?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH',
  ): Observable<AxiosResponse<WeeklyNumericRankingV3>>;
  public findMemberNumericRankingsHistoryV4(
    uniqueIndex: number,
    category?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH',
  ): Observable<any> {
    if (uniqueIndex === null || uniqueIndex === undefined) {
      throw new Error(
        'Required parameter uniqueIndex was null or undefined when calling findMemberNumericRankingsHistoryV4.',
      );
    }

    const queryParameters = new URLSearchParams();
    if (category !== undefined && category !== null) {
      queryParameters.append('category', <any>category);
    }

    const headers = { ...this.defaultHeaders };

    const accessTokenObservable: Observable<any> = of(null);

    // to determine the Accept header
    const httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers['Accept'] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers['Authorization'] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<WeeklyNumericRankingV3>(
          `${this.basePath}/v4/members/${encodeURIComponent(String(uniqueIndex))}/numeric-rankings`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
          },
        );
      }),
    );
  }
}
